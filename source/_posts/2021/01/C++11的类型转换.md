---
title: C++11的类型转换
categories: C++
date: 2021-01-22
---

# Type b = (Type)a
这个是 C 风格的强制类型转换，在现代 C++ 编程中，它已经是不被推荐，并且被视为不安全的操作。

C++11 中重新定义了四种新的类型转换操作符来替代旧的 C 风格的类型转换。

# dynamic_cast

首先说这个，是因为某些需要使用它的场合下，如果你一时图个方便，使用了旧的 C 风格的类型转换来代替它，那么可能会导致程序直接崩溃。

当你把一个基类指针转换成派生类指针的时候，一但他们实际上并不存在继承关系。这个时候：

1、如果你使用了 C 风格的类型转换，那么你是无法直接通过转换后的指针的值来判断，转换是否成功的（比如指针的值是否为 NULL ，因为不管转换是否成功，指针都会被赋予一个非空的值）。所以直到你对这个指针进行其它操作时才发现，程序崩溃了，这个时候才意识到，转换没有成功。

2、如果你使用了 dynamic_cast ，那么结果就不一样了。一旦转换失败，dynamic_cast 会返回 NULL 。此时，你可以通过判断结果指针的值是否为 NULL ，再对其进行后续操作。

所以当涉及到，具有继承关系的类的指针之间的转换时，使用它是最稳妥的方式。

# static_cast

这个通常的使用场景就是 C++ 基本类型之间的转换，没什么好说的。

# const_cast

这个主要是用来移除变量的 const 或者 volatile 修饰符。

# reinterpret_cast
重新解释 二进制的值

改变计算机对一个变量的解读方式

就像这一过程：

int a;

float* b = (float*)a;

二进制的值没有发生任何变化，但是计算机对其解读方式不一样了。

